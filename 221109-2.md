# 백준 단계별로 플어보기 - 이분 탐색: 가장 긴 증가하는 부분 수열 2 (12015번)
## 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

### 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

### 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

## 코드 및 해설
- LIS는 이전에 dp로 풀어본 적이 있음
- 그러나 dp로 풀게 되면 이중 for문을 써야 하기 때문에 시간 복잡도가 O(N^2)
- 이분 탐색으로 푸는 경우는 시간 복잡도가 O(NlogN)
- 이분 탐색으로 푸는 방법: 빈 리스트를 하나 만들고 현재 탐색중인 값이 들어갈 위치를 찾는다
  - Lower Bound 사용 필요
  - 나는 bisect 라이브러리를 사용해서 들어갈 위치를 찾음

### 알고리즘 동작
1. 빈 리스트를 하나 선언한다. 이 리스트에는 LIS를 만들 수 있는 값들을 넣는다 이후 이 배열 이름은 lis로 칭함
2. lis 초기값은 배열의 제일 첫번째 원소를 넣어둠
3. 배열을 탐색하면서 현재 탐색중인 원소가 lis의 마지막 원소보다 크면 뒤에 추가한다.
  3-1. 탐색중인 원소가 lis의 마지막 원소보다 작으면 해당 원소가 들어갈 수 있는 lis에서의 위치를 찾는다.
4. 해당 원소보다 작은 값 중 가장 큰 값 +1 (lower bound)을 찾아서 lis의 해당 인덱스(lower bound)를 해당 원소로 바꾼다
5. 위 3, 4 과정을 반복한다
6. 최종적으로 탐색을 끝낸 후의 lis의 길이가 최대로 만들 수 있는 증가하는 수열의 길이

### 코드
```python 
from bisect import bisect_left
import sys

input = sys.stdin.readline

n = int(input())
arr=list(map(int, input().split()))

lis = []
lis.append(arr[0])

for i in arr:
    if lis[-1]<i:
        lis.append(i)

    else:
        idx = bisect_left(lis, i)
        lis[idx] = i

print(len(lis))
```

## review
LIS를 이분 탑색으로 구현하는 거 이해하는 데에 시간이 좀 걸렸다

처음에 봤던 글은 정당성에 대해서 설명이 좀 부족해서 헷갈려서 댓글보고 이해했고 다른 글들도 찾아보면서 이해했음!

나는 조금 헷갈렸던 부분이 lis 배열의 끝값보다 작은 경우 lower bound를 찾아서 갱신하는 거였는데

그런 식으로 계속 갱신하면 새로운 증가 수열이 만들어지고, 만약 그렇게 만들어진 수열이 기존의 증가하는 수열보다 짧으면 결국 길이의 갱신은 이루어지지 않아서 이런 식으로 접근해도 가능하다고 이해하니 생각보다 금방 풀었다!

그리고 제대로 알고리즘 세워놓고 lis랑 arr를 바꿔쓰는 바람에 틀렸음...ㅎㅎ 변수 확인을 잘하자(제발)


