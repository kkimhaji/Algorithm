# 백준 단계별로 풀어보기 - 이분 탐색: K번째 수(1300번)
## 문제

세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.

### 입력
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.

### 출력
B[k]를 출력한다.


## 해설 및 코드
- 그냥 배열을 만들어서 풀면(브루트 포스) 시간 초과가 난다고 함
- 나는 메모리 초과가 났음(파이썬이라서 그런 듯)
- 그냥 규칙을 찾아서 계산하려고 하긴 했는데 이분 탐색인 만큼 이분 탐색을 사용한 방법으로 접근
- B[k]는 정렬한 후의 k번째 수이므로 k는 B[k]보다 작거나 같은 수의 개수
- 이차원 배열에서 k보다 작거나 같은 수의 개수는 어떤 수를 열의 인덱스로 나눈 값
- B[k]는 언제나 k보다 작거나 같은 수이므로 상한선은 k
- 완전히 k와 작은 수의 개수를 더한 값이 같지 않을 수 있으므로 Lower Bound를 사용해서 찾아야 함



### 코드
```python

import sys

input = sys.stdin.readline

n = int(input())
k = int(input())

def find_k(target, start, end):
    while start<=end:
        mid = (start+end)//2
        cnt = 0
        for i in range(1, n+1):
            cnt+= min(mid//i, n)
        
        if cnt<target:
            start = mid+1
        else:
            end = mid-1
    
    return end+1

print(find_k(k, 1, k))

```

## 후기
진짜 접근법 고민하느라고 시간을 다 보냈고...

중간에 자꾸 틀려서 뭐지? 했는데 min(mid/i, n)으로 써서 틀린 거였다 이거 고치는 것도 한참 걸림,,, 사소한 것들을 놓치지 말자
